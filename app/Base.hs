module Base where

import Prelude hiding (replicate, head, tail, map, subtract)
import Graphics.Gloss hiding (Vector)
import Graphics.Gloss.Data.ViewPort
import Data.Strict.Vector as V

import Constants

--Vec2f functions
type Vec2f = (Float, Float)

--Math
pythag :: Vec2f -> Float
pythag (x1, y1) = sqrt (x1 * x1 + y1 * y1)

dot :: Vec2f -> Vec2f -> Float
dot (x1, y1) (x2, y2) = x1 * x2 + y1 * y2

normalize :: Vec2f -> Vec2f
normalize (x, y) = (x / l, y / l)
    where l = pythag (x, y)

data Spring = Spring {
    damping :: Float,
    springConstant :: Float,
    anchorLength :: Float,
    node1 :: (Int, Int),
    node2 :: (Int, Int)
} deriving(Show)

--Functions for vec2f arithmetic
plus :: Vec2f -> Vec2f -> Vec2f 
plus (x1,y1) (x2,y2) = (x1 + x2, y1 + y2)

multiply :: Vec2f -> Float -> Vec2f
multiply (x1, y1) f = (x1 * f, y1 * f)

subtract :: Vec2f -> Vec2f -> Vec2f
subtract (x1, y1) (x2, y2) = (x1 - x2, y1 - y2)

divide :: Vec2f -> Float -> Vec2f
divide (x, y) f = (x / f, y / f)

--Node data structure 
data Node = Node {
    mass :: Float,
    gravity :: Float,
    radius :: Float,
    collisionRadius :: Float,
    pastPos :: Vec2f,
    position :: Vec2f,
    velocity :: Vec2f
} deriving(Eq, Show)

--Update past and present positions on a given vec2f
moveNode :: Node -> Vec2f -> Node
moveNode (Node m g r c pp p v) diff = Node m g r c p (p `plus` diff) v

--Simulation data structure
data Simulation = Simulation {
    nodes :: Vector (Vector Node),
    springs :: Vector Spring
} deriving(Show)


--Indexes position from nodes matrix(Vector Vector)
getPos :: Vector (Vector Node) -> (Int, Int) -> Vec2f
getPos nodes (i, j) = pos
    where
        (Node m g r c pp pos v) = nodes ! i ! j

--Converting 1D index to 2D provided the width
i1i2 :: Int -> Int -> (Int, Int) 
i1i2 ind w = (i, j)
    where
        i = ind `div` w 
        j = ind `rem` w


--Expanding the update ( // ) function provided in Data.Vector (Strict autogenerated version)
-- to facilitate two dimensional updates
updateNodes :: Vector (Vector a) -> [((Int, Int), a)] -> Vector (Vector a) 
updateNodes nodes [] = nodes
updateNodes nodes (((i, j), newNode) : updates) = seq newNodes (updateNodes newNodes updates)
    where
        newNodes = nodes // [(i, (nodes ! i) // [(j, newNode)])]

--Flatten 2D vector to 1D
flatten :: Vector (Vector a) -> Vector a
flatten nodes
    | V.null nodes = empty
    | otherwise = nodeH V.++ flatten nodesT
    where
        nodeH = head nodes
        nodesT = tail nodes


--Misc helper functions

--Exclusive range bound
inBounds :: Int -> Int -> Bool
inBounds ind bound = ind >= 0 && ind < bound

--Inclusive full bound
fullBound :: Int -> Int -> Int -> Bool
fullBound ind lower upper = ind >= lower && ind <= upper

--Function used to convert vector space from a centered origin to an origin in the top-left
translatePointOrigin :: Vec2f -> Vec2f
translatePointOrigin (x, y) = (x - (screenX / 2.0), (screenY / 2.0) - y)

--Drawing functions

springToPicture :: Vector (Vector Node) -> Spring -> Picture
springToPicture nodes (Spring d sc al n1 n2) = col line
    where
        diff = getPos nodes n2 `subtract` getPos nodes n1
        pushOrPull = (al - pythag diff) * 0.5 --Somewhat so of hookes law, but scaled correctly.
        colorCoef = tanh pushOrPull --Put within -1<->1 range
        
        line = Line [translatePointOrigin(getPos nodes n1), translatePointOrigin(getPos nodes n2)]

        
        (pullR, pullG, pullB) = pullColour
        (pushR, pushG, pushB) = pushColour

        maxC = max 0 colorCoef
        minC = (-1.0) * min 0 colorCoef 

        --(0.3, 0.3, 0.3) is the default colour with no forces acting
        --using max and min allows you to put the colours within range, and seperate them into -1 -> 0 and 0 -> 1
        col = color $! makeColor
                        (0.3 + maxC * pushR + minC * pullR) --Red
                        (0.3 + maxC * pushG + minC * pullG) --Green
                        (0.3 + maxC * pushB + minC * pullB) --Blue
                        1.0                                 --Alpha


nodeToPicture :: Node -> Picture
nodeToPicture (Node m g r c pp p v) = trans $ col cir
    where
        cir
            | filledNodes = circleSolid r
            | otherwise = Circle r
        
        (rf, gf, bf) = nodeColour
        col = color $ makeColor rf gf bf 1.0

        (x, y) = translatePointOrigin p
        trans = translate x y


drawWalls :: Picture
drawWalls = Pictures [
                left,right,roof,floor 
            ]
    where
        --Lines for the walls
        wallCol = color $ makeColor 0.4 0.4 0.4 1.0

        roof = wallCol $ line [translatePointOrigin(0.0, 0.0), translatePointOrigin(screenX, 0.0)]
        floor = translate 0.0 (-screenY) roof

        left = wallCol $ line [translatePointOrigin(0.0, 0.0), translatePointOrigin(0.0, screenY)]
        right = translate screenX 0.0 left
        

draw :: Simulation -> Picture
draw (Simulation nodes springs) = res
    where
        res = Pictures (drawWalls : toList (
                map (springToPicture nodes) springs --Draw springs first so nodes appear on top
                V.++
                nodePic
            ))

        nodePic
            | showNodes = map nodeToPicture flattened
            | otherwise = empty
        flattened = flatten nodes
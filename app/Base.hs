module Base where

import Prelude hiding (replicate, head, tail, map)
import Graphics.Gloss hiding (Vector)
import Graphics.Gloss.Data.ViewPort
import Data.Strict.Vector as V

import Constants

--Vec2f functions
type Vec2f = (Float, Float)

pythag :: Vec2f -> Float
pythag (x1, y1) = sqrt (x1 * x1 + y1 * y1)

dot :: Vec2f -> Vec2f -> Float
dot (x1, y1) (x2, y2) = x1 * x2 + y1 * y2

normalize :: Vec2f -> Vec2f
normalize (x, y) = (x / l, y / l)
    where l = pythag (x, y)

data Spring = Spring {
    damping :: Float,
    springConstant :: Float,
    anchorLength :: Float,
    node1 :: (Int, Int),
    node2 :: (Int, Int)
} deriving(Show)

--Todo: define actual operators for these!
pv :: Vec2f -> Vec2f -> Vec2f 
pv (x1,y1) (x2,y2) = (x1 + x2, y1 + y2)

mv :: Vec2f -> Float -> Vec2f
mv (x1, y1) f = (x1 * f, y1 * f)

sv :: Vec2f -> Vec2f -> Vec2f
sv (x1, y1) (x2, y2) = (x1 - x2, y1 - y2)

dv :: Vec2f -> Float -> Vec2f
dv (x, y) f = (x / f, y / f)

--Node data structure 
data Node = Node {
    mass :: Float,
    gravity :: Float,
    radius :: Float,
    collisionRadius :: Float,
    pastPos :: Vec2f,
    position :: Vec2f,
    velocity :: Vec2f
} deriving(Eq, Show)

moveNode :: Node -> Vec2f -> Node
moveNode (Node m g r c pp p v) diff = Node m g r c p (p `pv` diff) v

--Simulation data structure
data Simulation = Simulation {
    nodes :: Vector (Vector Node),
    springs :: Vector Spring
} deriving(Show)


getPos :: Vector (Vector Node) -> (Int, Int) -> Vec2f
getPos nodes (i, j) = pos
    where
        (Node m g r c pp pos v) = nodes ! i ! j

i1i2 :: Int -> Int -> (Int, Int) 
i1i2 ind w = (i, j)
    where
        i = ind `div` w 
        j = ind `rem` w


--Expanding the update ( // ) function provided in Data.Vector (Strict autogenerated version) to facilitate two dimensional updates
updateNodes :: Vector (Vector a) -> [((Int, Int), a)] -> Vector (Vector a) 
updateNodes nodes [] = nodes
updateNodes nodes (((i, j), newNode) : updates) = seq newNodes (updateNodes newNodes updates)
    where
        newNodes = nodes // [(i, (nodes ! i) // [(j, newNode)])]


flatten :: Vector (Vector a) -> Vector a
flatten nodes
    | V.null nodes = empty
    | otherwise = nodeH V.++ flatten nodesT
    where
        nodeH = head nodes
        nodesT = tail nodes


--Misc helper functions

--Exclusive range bound
inBounds :: Int -> Int -> Bool
inBounds ind bound = ind >= 0 && ind < bound

--Inclusive full bound
fullBound :: Int -> Int -> Int -> Bool
fullBound ind lower upper = ind >= lower && ind <= upper

--Function used to convert vector space from a centered origin to an origin in the top-left
translatePointOrigin :: Vec2f -> Vec2f
translatePointOrigin (x, y) = (x - (screenX / 2.0), (screenY / 2.0) - y)

--Drawing functions

springToPicture :: Vector (Vector Node) -> Spring -> Picture
springToPicture nodes (Spring d sc al n1 n2) = col line
    where
        diff = getPos nodes n2 `sv` getPos nodes n1
        pushOrPull = (al - pythag diff) * 0.1
        colorCoef = tanh pushOrPull --Put within -1<->1 range
        
        line = Line [translatePointOrigin(getPos nodes n1), translatePointOrigin(getPos nodes n2)]

        --Red = Spring is compressed, blue = spring is extended
        col = color $! makeColor (0.3 + max 0 colorCoef) 0.3 (0.3 + (-1.0) * min 0 colorCoef) 1.0


nodeToPicture :: Node -> Picture
nodeToPicture (Node m g r c pp p v) = trans $ col cir
    where
        cir = Circle r
        col = color $ makeColor 0.4 0.4 0.4 1.0

        (x, y) = translatePointOrigin p
        trans = translate x y


drawWalls :: Picture
drawWalls = Pictures [
                left,right,roof,floor 
            ]
    where
        wallCol = color $ makeColor 0.4 0.4 0.4 1.0
        roof = wallCol $ line [translatePointOrigin(0.0, 0.0), translatePointOrigin(screenX, 0.0)]
        floor = translate 0.0 (-screenY) roof
        left = wallCol $ line [translatePointOrigin(0.0, 0.0), translatePointOrigin(0.0, screenY)]
        right = translate screenX 0.0 left
        

draw :: Simulation -> Picture
draw (Simulation nodes springs) = res
    where
        res = Pictures (drawWalls : toList (
                map nodeToPicture flattened V.++
                map (springToPicture nodes) springs
            ))

        flattened = flatten nodes